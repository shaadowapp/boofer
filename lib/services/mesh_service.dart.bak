import 'dart:async';
import 'dart:convert';
import 'dart:typed_data';
import 'package:bridgefy/bridgefy.dart';
import 'package:rxdart/rxdart.dart';
import '../models/message_model.dart';
import 'message_repository.dart';
import 'mesh_message_handler.dart';
import 'mesh_reception_handler.dart';

/// Interface for mesh networking service
abstract class IMeshService {
  Stream<Message> get incomingMessages;
  Stream<int> get connectedPeersCount;
  Stream<bool> get isActive;
  Future<void> initialize(String apiKey);
  Future<void> start();
  Future<void> stop();
  Future<void> sendMeshMessage(String text, String senderId);
  bool get isInitialized;
  bool get isStarted;
  int get peersCount;
}

/// Mesh networking service using Bridgefy SDK
class MeshService implements IMeshService {
  static MeshService? _instance;
  final IMessageRepository _messageRepository;
  final MeshReceptionHandler _receptionHandler;
  
  // Streams for reactive updates
  final BehaviorSubject<Message> _incomingMessagesController = BehaviorSubject<Message>();
  final BehaviorSubject<int> _connectedPeersController = BehaviorSubject<int>.seeded(0);
  final BehaviorSubject<bool> _isActiveController = BehaviorSubject<bool>.seeded(false);
  
  bool _isInitialized = false;
  bool _isStarted = false;
  int _peersCount = 0;
  String? _currentUserId;

  MeshService._({required IMessageRepository messageRepository})
      : _messageRepository = messageRepository,
        _receptionHandler = MeshReceptionHandler(messageRepository: messageRepository) {
    // Forward processed messages from reception handler
    _receptionHandler.processedMessages.listen((message) {
      _incomingMessagesController.add(message);
    });
  }

  static MeshService getInstance({IMessageRepository? messageRepository}) {
    _instance ??= MeshService._(
      messageRepository: messageRepository ?? MessageRepository(),
    );
    return _instance!;
  }

  @override
  Stream<Message> get incomingMessages => _incomingMessagesController.stream;

  @override
  Stream<int> get connectedPeersCount => _connectedPeersController.stream;

  @override
  Stream<bool> get isActive => _isActiveController.stream;

  @override
  bool get isInitialized => _isInitialized;

  @override
  bool get isStarted => _isStarted;

  @override
  int get peersCount => _peersCount;

  @override
  Future<void> initialize(String apiKey) async {
    if (_isInitialized) {
      print('MeshService already initialized');
      return;
    }

    try {
      print('Initializing Bridgefy SDK...');
      
      // Initialize Bridgefy with the provided API key
      await Bridgefy.initialize(apiKey: apiKey);
      
      // Set up event listeners
      _setupEventListeners();
      
      _isInitialized = true;
      print('MeshService initialized successfully');
    } catch (e) {
      print('Failed to initialize MeshService: $e');
      _isInitialized = false;
      rethrow;
    }
  }

  @override
  Future<void> start() async {
    if (!_isInitialized) {
      throw Exception('MeshService not initialized. Call initialize() first.');
    }

    if (_isStarted) {
      print('MeshService already started');
      return;
    }

    try {
      print('Starting mesh networking...');
      
      // Start Bridgefy with standard propagation profile
      // This enables multi-hop message relay through intermediate devices
      await Bridgefy.start(
        propagationProfile: BridgefyPropagationProfile.standard,
      );
      
      _isStarted = true;
      _isActiveController.add(true);
      print('Mesh networking started successfully');
    } catch (e) {
      print('Failed to start mesh networking: $e');
      _isStarted = false;
      _isActiveController.add(false);
      rethrow;
    }
  }

  @override
  Future<void> stop() async {
    if (!_isStarted) {
      print('MeshService not started');
      return;
    }

    try {
      print('Stopping mesh networking...');
      
      await Bridgefy.stop();
      
      _isStarted = false;
      _peersCount = 0;
      _isActiveController.add(false);
      _connectedPeersController.add(0);
      
      print('Mesh networking stopped successfully');
    } catch (e) {
      print('Failed to stop mesh networking: $e');
      rethrow;
    }
  }

  @override
  Future<void> sendMeshMessage(String text, String senderId) async {
    if (!_isStarted) {
      throw Exception('MeshService not started. Call start() first.');
    }

    try {
      // Create message object
      final message = Message.create(
        text: text,
        senderId: senderId,
        isOffline: true,
        status: MessageStatus.pending,
      );

      // Validate message before sending
      if (!MeshMessageHandler.validateMessage(message)) {
        throw Exception('Message validation failed');
      }

      // Serialize message for transmission
      final bytes = MeshMessageHandler.serializeMessage(message);

      print('Sending mesh message: $text (${bytes.length} bytes)');

      // Broadcast message to all connected peers
      // The Bridgefy SDK handles the multi-hop propagation automatically
      await Bridgefy.sendBroadcastMessage(bytes);

      // Update message status to sent and save to local database
      message.status = MessageStatus.sent;
      await _messageRepository.saveMessage(message);

      print('Message sent successfully via mesh network');
    } catch (e) {
      print('Failed to send mesh message: $e');
      
      // Save message as failed for retry later
      final failedMessage = Message.create(
        text: text,
        senderId: senderId,
        isOffline: true,
        status: MessageStatus.failed,
      );
      await _messageRepository.saveMessage(failedMessage);
      
      rethrow;
    }
  }

  /// Set up Bridgefy event listeners
  void _setupEventListeners() {
    // Listen for incoming data from other devices
    Bridgefy.bridgefyDidReceiveData.listen((data) {
      _handleIncomingData(data);
    });

    // Listen for device connections
    Bridgefy.bridgefyDidConnect.listen((device) {
      _handleDeviceConnected(device);
    });

    // Listen for device disconnections
    Bridgefy.bridgefyDidDisconnect.listen((device) {
      _handleDeviceDisconnected(device);
    });

    // Listen for Bridgefy start events
    Bridgefy.bridgefyDidStart.listen((device) {
      _handleBridgefyStarted(device);
    });

    // Listen for Bridgefy stop events
    Bridgefy.bridgefyDidStop.listen((_) {
      _handleBridgefyStopped();
    });

    // Listen for errors
    Bridgefy.bridgefyDidFailToStart.listen((error) {
      _handleBridgefyError('Failed to start: $error');
    });

    Bridgefy.bridgefyDidFailToStop.listen((error) {
      _handleBridgefyError('Failed to stop: $error');
    });
  }

  /// Handle incoming data from mesh network
  void _handleIncomingData(BridgefyMessage bridgefyMessage) async {
    try {
      print('Received mesh data: ${bridgefyMessage.data.length} bytes from ${bridgefyMessage.senderId}');

      // Use the reception handler to process the incoming data
      await _receptionHandler.processIncomingData(
        bridgefyMessage.data,
        bridgefyMessage.senderId,
      );

    } catch (e) {
      print('Error handling incoming mesh data: $e');
    }
  }

  /// Handle device connection
  void _handleDeviceConnected(BridgefyDevice device) {
    _peersCount++;
    _connectedPeersController.add(_peersCount);
    print('Device connected: ${device.deviceId} (Total peers: $_peersCount)');
  }

  /// Handle device disconnection
  void _handleDeviceDisconnected(BridgefyDevice device) {
    _peersCount = (_peersCount - 1).clamp(0, double.infinity).toInt();
    _connectedPeersController.add(_peersCount);
    print('Device disconnected: ${device.deviceId} (Total peers: $_peersCount)');
  }

  /// Handle Bridgefy started
  void _handleBridgefyStarted(BridgefyDevice device) {
    _currentUserId = device.deviceId;
    print('Bridgefy started with device ID: ${device.deviceId}');
  }

  /// Handle Bridgefy stopped
  void _handleBridgefyStopped() {
    _peersCount = 0;
    _connectedPeersController.add(0);
    print('Bridgefy stopped');
  }

  /// Handle Bridgefy errors
  void _handleBridgefyError(String error) {
    print('Bridgefy error: $error');
    _isActiveController.add(false);
  }

  /// Get current user ID (device ID)
  String? get currentUserId => _currentUserId;

  /// Check if mesh networking is available
  Future<bool> isAvailable() async {
    try {
      // This would check if Bluetooth/WiFi is available
      // Implementation depends on Bridgefy SDK capabilities
      return _isInitialized;
    } catch (e) {
      print('Error checking mesh availability: $e');
      return false;
    }
  }

  /// Get reception handler statistics
  Map<String, dynamic> getReceptionStatistics() {
    return _receptionHandler.getStatistics();
  }
}