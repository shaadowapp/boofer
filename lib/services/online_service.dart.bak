import 'dart:async';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:rxdart/rxdart.dart';
import '../models/message_model.dart';
import 'message_repository.dart';

/// Interface for online communication service
abstract class IOnlineService {
  Stream<Message> get incomingMessages;
  Stream<bool> get isConnected;
  Future<void> initialize(String supabaseUrl, String supabaseAnonKey);
  Future<void> connect();
  Future<void> disconnect();
  Future<void> sendOnlineMessage(String text, String senderId);
  Future<void> syncOfflineMessages(List<Message> messages);
  bool get isInitialized;
  bool get isOnline;
}

/// Online communication service using Supabase
class OnlineService implements IOnlineService {
  static OnlineService? _instance;
  final IMessageRepository _messageRepository;
  
  // Supabase client
  SupabaseClient? _supabase;
  RealtimeChannel? _messagesChannel;
  
  // Streams for reactive updates
  final BehaviorSubject<Message> _incomingMessagesController = BehaviorSubject<Message>();
  final BehaviorSubject<bool> _isConnectedController = BehaviorSubject<bool>.seeded(false);
  
  bool _isInitialized = false;
  bool _isOnline = false;
  String? _currentUserId;
  
  // Configuration
  String? _supabaseUrl;
  String? _supabaseAnonKey;

  OnlineService._({required IMessageRepository messageRepository})
      : _messageRepository = messageRepository;

  static OnlineService getInstance({IMessageRepository? messageRepository}) {
    _instance ??= OnlineService._(
      messageRepository: messageRepository ?? MessageRepository(),
    );
    return _instance!;
  }

  @override
  Stream<Message> get incomingMessages => _incomingMessagesController.stream;

  @override
  Stream<bool> get isConnected => _isConnectedController.stream;

  @override
  bool get isInitialized => _isInitialized;

  @override
  bool get isOnline => _isOnline;

  @override
  Future<void> initialize(String supabaseUrl, String supabaseAnonKey) async {
    if (_isInitialized) {
      print('OnlineService already initialized');
      return;
    }

    try {
      print('Initializing Supabase client...');
      
      _supabaseUrl = supabaseUrl;
      _supabaseAnonKey = supabaseAnonKey;
      
      // Initialize Supabase
      await Supabase.initialize(
        url: supabaseUrl,
        anonKey: supabaseAnonKey,
        debug: true, // Enable debug mode for development
      );
      
      _supabase = Supabase.instance.client;
      _isInitialized = true;
      
      print('OnlineService initialized successfully');
    } catch (e) {
      print('Failed to initialize OnlineService: $e');
      _isInitialized = false;
      rethrow;
    }
  }

  @override
  Future<void> connect() async {
    if (!_isInitialized) {
      throw Exception('OnlineService not initialized. Call initialize() first.');
    }

    if (_isOnline) {
      print('OnlineService already connected');
      return;
    }

    try {
      print('Connecting to online service...');
      
      // Set up real-time subscription for messages
      await _setupRealtimeSubscription();
      
      _isOnline = true;
      _isConnectedController.add(true);
      
      print('Connected to online service successfully');
    } catch (e) {
      print('Failed to connect to online service: $e');
      _isOnline = false;
      _isConnectedController.add(false);
      rethrow;
    }
  }

  @override
  Future<void> disconnect() async {
    if (!_isOnline) {
      print('OnlineService not connected');
      return;
    }

    try {
      print('Disconnecting from online service...');
      
      // Unsubscribe from real-time updates
      await _messagesChannel?.unsubscribe();
      _messagesChannel = null;
      
      _isOnline = false;
      _isConnectedController.add(false);
      
      print('Disconnected from online service successfully');
    } catch (e) {
      print('Failed to disconnect from online service: $e');
      rethrow;
    }
  }

  @override
  Future<void> sendOnlineMessage(String text, String senderId) async {
    if (!_isOnline) {
      throw Exception('OnlineService not connected. Call connect() first.');
    }

    try {
      // Create message object
      final message = Message.create(
        text: text,
        senderId: senderId,
        isOffline: false,
        status: MessageStatus.pending,
      );

      print('Sending online message: $text');

      // Insert message into Supabase
      final response = await _supabase!
          .from('messages')
          .insert(_messageToSupabaseJson(message))
          .select()
          .single();

      // Update message with server-assigned ID and mark as sent
      message.id = response['id'] as int;
      message.status = MessageStatus.sent;
      
      // Save to local database
      await _messageRepository.saveMessage(message);

      print('Message sent successfully via online service');
    } catch (e) {
      print('Failed to send online message: $e');
      
      // Save message as failed for retry later
      final failedMessage = Message.create(
        text: text,
        senderId: senderId,
        isOffline: false,
        status: MessageStatus.failed,
      );
      await _messageRepository.saveMessage(failedMessage);
      
      rethrow;
    }
  }

  @override
  Future<void> syncOfflineMessages(List<Message> messages) async {
    if (!_isOnline) {
      throw Exception('OnlineService not connected. Call connect() first.');
    }

    if (messages.isEmpty) {
      print('No offline messages to sync');
      return;
    }

    try {
      print('Syncing ${messages.length} offline messages...');
      
      final syncedMessages = <Message>[];
      final failedMessages = <Message>[];

      for (final message in messages) {
        try {
          // Convert offline message to online format
          final onlineMessage = Message.create(
            text: message.text,
            senderId: message.senderId,
            isOffline: false, // Mark as online after sync
            conversationId: message.conversationId,
            timestamp: message.timestamp,
          );

          // Insert into Supabase
          final response = await _supabase!
              .from('messages')
              .insert(_messageToSupabaseJson(onlineMessage))
              .select()
              .single();

          // Update with server ID and mark as delivered
          onlineMessage.id = response['id'] as int;
          onlineMessage.status = MessageStatus.delivered;
          
          syncedMessages.add(onlineMessage);
          
          // Update original message status
          await _messageRepository.updateMessageStatus(
            message.id, 
            MessageStatus.delivered,
          );

        } catch (e) {
          print('Failed to sync message ${message.id}: $e');
          failedMessages.add(message);
          
          // Mark as failed
          await _messageRepository.updateMessageStatus(
            message.id, 
            MessageStatus.failed,
          );
        }
      }

      print('Sync completed: ${syncedMessages.length} successful, ${failedMessages.length} failed');
      
    } catch (e) {
      print('Failed to sync offline messages: $e');
      rethrow;
    }
  }

  /// Set up real-time subscription for incoming messages
  Future<void> _setupRealtimeSubscription() async {
    try {
      _messagesChannel = _supabase!
          .channel('messages')
          .onPostgresChanges(
            event: PostgresChangeEvent.insert,
            schema: 'public',
            table: 'messages',
            callback: _handleIncomingMessage,
          );

      await _messagesChannel!.subscribe();
      
      print('Real-time subscription established');
    } catch (e) {
      print('Failed to set up real-time subscription: $e');
      rethrow;
    }
  }

  /// Handle incoming message from real-time subscription
  void _handleIncomingMessage(PostgresChangePayload payload) async {
    try {
      print('Received online message: ${payload.newRecord}');

      // Convert Supabase record to Message object
      final message = _messageFromSupabaseJson(payload.newRecord);
      
      // Don't process our own messages
      if (message.senderId == _currentUserId) {
        return;
      }

      // Check for duplicate messages
      if (message.messageHash != null && 
          await _messageRepository.messageExists(message.messageHash!)) {
        print('Duplicate online message received, ignoring: ${message.messageHash}');
        return;
      }

      // Mark as delivered and save to local database
      message.status = MessageStatus.delivered;
      await _messageRepository.saveMessage(message);

      // Emit the message to listeners
      _incomingMessagesController.add(message);

      print('Online message received and saved: ${message.text}');
    } catch (e) {
      print('Error handling incoming online message: $e');
    }
  }

  /// Convert Message object to Supabase JSON format
  Map<String, dynamic> _messageToSupabaseJson(Message message) {
    return {
      'text': message.text,
      'sender_id': message.senderId,
      'timestamp': message.timestamp.toIso8601String(),
      'is_offline': message.isOffline,
      'status': message.status.name,
      'conversation_id': message.conversationId,
      'message_hash': message.messageHash,
      'created_at': DateTime.now().toIso8601String(),
    };
  }

  /// Convert Supabase JSON to Message object
  Message _messageFromSupabaseJson(Map<String, dynamic> json) {
    final message = Message();
    message.id = json['id'] as int? ?? 0;
    message.text = json['text'] as String;
    message.senderId = json['sender_id'] as String;
    message.timestamp = DateTime.parse(json['timestamp'] as String);
    message.isOffline = json['is_offline'] as bool? ?? false;
    message.status = MessageStatus.values.firstWhere(
      (status) => status.name == json['status'],
      orElse: () => MessageStatus.delivered,
    );
    message.conversationId = json['conversation_id'] as String?;
    message.messageHash = json['message_hash'] as String?;
    return message;
  }

  /// Get recent messages from server
  Future<List<Message>> getRecentMessages({int limit = 50}) async {
    if (!_isOnline) {
      throw Exception('OnlineService not connected');
    }

    try {
      final response = await _supabase!
          .from('messages')
          .select()
          .order('timestamp', ascending: false)
          .limit(limit);

      final messages = (response as List)
          .map((json) => _messageFromSupabaseJson(json))
          .toList();

      print('Retrieved ${messages.length} recent messages from server');
      return messages;
    } catch (e) {
      print('Failed to get recent messages: $e');
      rethrow;
    }
  }

  /// Get messages by conversation from server
  Future<List<Message>> getConversationMessages(String conversationId) async {
    if (!_isOnline) {
      throw Exception('OnlineService not connected');
    }

    try {
      final response = await _supabase!
          .from('messages')
          .select()
          .eq('conversation_id', conversationId)
          .order('timestamp', ascending: true);

      final messages = (response as List)
          .map((json) => _messageFromSupabaseJson(json))
          .toList();

      print('Retrieved ${messages.length} messages for conversation $conversationId');
      return messages;
    } catch (e) {
      print('Failed to get conversation messages: $e');
      rethrow;
    }
  }

  /// Set current user ID
  void setCurrentUserId(String userId) {
    _currentUserId = userId;
    print('Current user ID set to: $userId');
  }

  /// Get connection status
  Map<String, dynamic> getConnectionStatus() {
    return {
      'isInitialized': _isInitialized,
      'isOnline': _isOnline,
      'hasRealtimeSubscription': _messagesChannel != null,
      'currentUserId': _currentUserId,
    };
  }

  /// Dispose resources
  void dispose() {
    _messagesChannel?.unsubscribe();
    _incomingMessagesController.close();
    _isConnectedController.close();
  }
}